"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5543],{35543:function(e,t,i){i.r(t),i.d(t,{default:function(){return $}});var s=i(48111);class n{constructor(e){this.id=e,this.intent="unsubscribed",this.state="idle",this.channels=[],this.disposed=!1,this._pendings=[]}add(e){this.channels.includes(e)||this.channels.push(e)}remove(e){let t=this.channels.indexOf(e);t>-1&&this.channels.splice(t,1)}notify(e,...t){this.state=e,1===t.length?this.channels.forEach((i=>i[e](t[0]))):this.channels.forEach((t=>t[e]()))}pending(e){this._checkIntent(e);let t=this._pendings[0];return t&&t.intent===e?t.promise:Promise.resolve()}ensureResubscribed(){this.disposed||(this.intent=void 0,this.ensureSubscribed())}ensureSubscribed(){if("subscribed"===this.intent)return;if(this.disposed)throw Error("Subscription is disposed");this.intent="subscribed",this._mergeWithPending("unsubscribed")||this.subscriber(this)}maybeUnsubscribe(){if(this.disposed)return;if("unsubscribed"===this.intent)return;if(this.channels.length>0)return;this.intent="unsubscribed",this._mergeWithPending("subscribed")||this.unsubscriber(this)}async acquire(e){let t;this._checkIntent(e);let i={promise:new Promise((e=>{t=e})),intent:e,release:()=>{this._pendings.splice(this._pendings.indexOf(i),1),t(i)},canceled:!1,acquired:!1},s=this._pendingTop;return this._pendings.push(i),s&&await s.promise,i.acquired=!0,i}close(e){this.disposed=!0,this.intent=void 0,this.notify("closed",e)}_checkIntent(e){if("unsubscribed"!==e&&"subscribed"!==e)throw Error(`Unknown subscription intent: ${e}`)}get _pendingTop(){return this._pendings.length?this._pendings[this._pendings.length-1]:void 0}_mergeWithPending(e){let t=this._pendingTop;return!!t&&(!t.acquired&&(t.intent===e&&(this._pendings.pop(),t.canceled=!0,!0)))}}class r{constructor(){this._subscriptions={},this._localToRemote={}}all(){return Object.values(this._subscriptions)}get(e){return this._subscriptions[e]}create(e,{subscribe:t,unsubscribe:i}){let s=this._subscriptions[e]=new n(e);return s.remoteId=this._localToRemote[e],s.subscriber=t,s.unsubscriber=i,s}remove(e){delete this._subscriptions[e],delete this._localToRemote[e]}storeRemoteId(e,t){this._localToRemote[e]=t;let i=this.get(e);i&&(i.remoteId=t)}}class o{constructor(){this.subscriptions=new r,this._pendingMessages=[],this._remoteToLocal={}}subscribe(e,t){this._remoteToLocal[t]=e,this.subscriptions.storeRemoteId(e,t),this.flush(t)}unsubscribe(e){let t=this.subscriptions.get(e);if(!t)return;let i=t.remoteId;i&&delete this._remoteToLocal[i],this.subscriptions.remove(e)}transmit(e,t,i){let s=this._remoteToLocal[e];if(!s)return void this._pendingMessages.push([e,t,i]);let n=this.subscriptions.get(s);n&&n.channels.forEach((e=>{e.receive(t,i)}))}close(){this._pendingMessages.length=0}get size(){return this.channels.length}get channels(){return this.subscriptions.all().flatMap((e=>e.channels))}flush(e){let t=[];for(let i of this._pendingMessages)i[0]===e?this.transmit(i[0],i[1],i[2]):t.push(i);this._pendingMessages=t}}var c=i(73605);const h={debug:0,info:1,warn:2,error:3};class d{constructor(e){this.level=e||"warn"}log(e,t,i){h[e]<h[this.level]||this.writeLogEntry(e,t,i)}writeLogEntry(){throw Error("Not implemented")}debug(e,t){this.log("debug",e,t)}info(e,t){this.log("info",e,t)}warn(e,t){this.log("warn",e,t)}error(e,t){this.log("error",e,t)}}class l extends d{writeLogEntry(){}}var a=i(5975);class u extends c.Bo{constructor(){super("No connection","closed"),this.name="NoConnectionError"}}class g extends a.${static identifier="__ghost__";constructor(e,t){super(t),this.channelId=e}set channelId(e){this._channelId=e}get channelId(){return this._channelId}}const b=Symbol("state");class p{constructor({transport:e,protocol:t,encoder:i,logger:n,lazy:r}){this.emitter=(0,s.i)(),this.transport=e,this.encoder=i,this.logger=n||new l,this.protocol=t,this.protocol.attached(this),this.hub=new o,this[b]="idle",this.handleClose=this.handleClose.bind(this),this.handleIncoming=this.handleIncoming.bind(this),this.transport.on("close",this.handleClose),this.transport.on("data",this.handleIncoming),this.initialConnect=!0,this.recovering=!1,!1===r&&this.connect().catch((()=>{}))}get state(){return this[b]}async connect(){if("connected"===this.state)return Promise.resolve();if("connecting"===this.state)return this.pendingConnect();this[b]="connecting";let e=this.pendingConnect();this.logger.debug("connecting");try{await this.transport.open()}catch(t){this.handleClose(t)}return e}connected(){if("connected"===this.state)return;this.logger.info("connected"),this[b]="connected",this.recovering&&this.hub.subscriptions.all().forEach((e=>e.notify("disconnected",new c.lZ("recovery_failed")))),this.hub.subscriptions.all().forEach((e=>this._resubscribe(e)));this.recovering=!1,this.initialConnect?(this.initialConnect=!1,this.emit("connect",{reconnect:!1,restored:false})):this.emit("connect",{reconnect:!0,restored:false})}restored(e){if(!this.recovering)return void this.connected();this.logger.info("connection recovered",{remoteIds:e}),this[b]="connected",this.hub.subscriptions.all().forEach((t=>{e&&t.remoteId&&e.includes(t.remoteId)?t.notify("restored"):(t.notify("disconnected",new c.lZ("recovery_failed")),this._resubscribe(t))}));let t=!this.initialConnect;this.recovering=!1,this.initialConnect=!1,this.emit("connect",{reconnect:t,restored:!0})}handleClose(e){this.logger.debug("transport closed",{error:e}),this.disconnected(new c.lZ(e,"transport_closed"))}disconnected(e){"connected"!==this.state&&"connecting"!==this.state||(this.logger.info("disconnected",{reason:e}),this[b]="disconnected",this.recovering=this.protocol.recoverableClosure(e),this.recovering?this.hub.subscriptions.all().forEach((e=>e.notify("connecting"))):this.hub.subscriptions.all().forEach((t=>{t.notify("disconnected",e)})),this.protocol.reset(e),this.hub.close(),this.transport.close(),this.emit("disconnect",e))}closed(e){if("closed"===this.state||"idle"===this.state)return;let t;e&&(t=e instanceof c.lZ?e:new c.lZ(e,void 0)),this.logger.info("closed",{reason:e||"user"}),this[b]="closed";let i=t||new c.lZ("cable_closed");this.hub.subscriptions.all().forEach((e=>e.notify("disconnected",i))),this.hub.close(),this.protocol.reset(),this.transport.close(),this.initialConnect=!0,this.emit("close",t)}disconnect(){this.closed()}handleIncoming(e){if("closed"===this.state||"idle"===this.state)return;let t=this.encoder.decode(e);if(void 0===t)return void this.logger.error("failed to decode message",{message:e});this.logger.debug("incoming data",t);let i=this.protocol.receive(t);if(i){this.logger.debug("processed incoming message",i);let{identifier:e,message:t,meta:s}=i;this.hub.transmit(e,t,s)}}send(e){if("closed"===this.state)throw Error("Cable is closed");let t=this.encoder.encode(e);void 0!==t?(this.logger.debug("outgoing message",e),this.transport.send(t)):this.logger.error("failed to encode message",{message:e})}keepalive(e){this.emit("keepalive",e)}subscribeTo(e,t){let i,s;return"string"===typeof e&&(s=e,e=g),i=s?new e(s,t):new e(t),this.subscribe(i)}subscribe(e){if(!e.attached(this))return e;let t=e.identifier;e.connecting();let i=this.hub.subscriptions.get(t)||this.hub.subscriptions.create(t,{subscribe:t=>this._subscribe(t,e.channelId,e.params),unsubscribe:e=>this._unsubscribe(e)});return i.add(e),"subscribed"===i.intent&&"connected"===i.state&&e.connected(),i.ensureSubscribed(),e}async _resubscribe(e){if("subscribed"!==e.intent)return;e.channels[0]&&(e.notify("connecting"),e.ensureResubscribed())}async _subscribe(e,t,i){let s=e.id;if("idle"===this.state&&this.connect().catch((()=>{})),"connected"!==this.state)return void this.logger.debug("cancel subscribe, no connection",{identifier:s});this.logger.debug("acquiring subscribe lock",{identifier:s});let n=await e.acquire("subscribed");if(n.canceled)return this.logger.debug("subscribe lock has been canceled",{identifier:s}),void n.release();if(this.logger.debug("subscribe lock has been acquired",{identifier:s}),"subscribed"!==e.intent)return this.logger.debug("cancel subscribe request, already unsubscribed"),void n.release();if("connected"!==this.state)return this.logger.debug("cancel subscribe, no connection",{identifier:s}),void n.release();if("connected"===e.state)return this.logger.debug("already connected, skip subscribe command",{identifier:s}),e.notify("connected"),void n.release();let r={identifier:t,params:i};this.logger.debug("subscribing",r);try{let n=await this.protocol.subscribe(t,i);this.hub.subscribe(s,n),this.logger.debug("subscribed",{...r,remoteId:n}),e.notify("connected")}catch(o){if(o){if(o instanceof c.RB&&this.logger.warn("rejected",r),o instanceof c.lZ)return this.logger.debug("disconnected during subscription; will retry on connect",r),void n.release();this.logger.error("failed to subscribe",{error:o,...r})}e.close(o),this.hub.unsubscribe(s)}n.release()}unsubscribe(e){let t=e.identifier,i=this.hub.subscriptions.get(t);if(!i)throw Error(`Subscription not found: ${t}`);i.remove(e),e.closed(),i.maybeUnsubscribe()}async _unsubscribe(e){let t=e.id;this.logger.debug("acquiring unsubscribe lock",{identifier:t});let i=await e.acquire("unsubscribed");if(i.canceled)return this.logger.debug("unsubscribe lock has been canceled",{identifier:t}),void i.release();if(this.logger.debug("unsubscribe lock has been acquired",{identifier:t}),"unsubscribed"!==e.intent)return this.logger.debug("cancel unsubscribe, no longer needed",{identifier:t,intent:e.intent}),void i.release();if("disconnected"===e.state||"closed"===e.state)return this.logger.debug(`already ${e.state} connected, skip unsubscribe command`,{identifier:t}),void i.release();let s=e.remoteId;if(this.logger.debug("unsubscribing...",{remoteId:s}),"connected"!==this.state)return this.logger.debug("unsubscribe skipped (cable is not connected)",{id:t}),e.close(),this.hub.unsubscribe(t),void i.release();try{await this.protocol.unsubscribe(s),this.logger.debug("unsubscribed remotely",{id:t})}catch(n){n&&(n instanceof c.lZ?this.logger.debug("cable disconnected during the unsubscribe command execution",{id:t,error:n}):this.logger.error("unsubscribe failed",{id:t,error:n}))}"unsubscribed"===e.intent?(e.close(),this.hub.unsubscribe(t)):e.state="closed",i.release()}async perform(e,t,i){if("connecting"===this.state&&await this.pendingConnect(),"closed"===this.state||"disconnected"===this.state)throw new u;let s=this.hub.subscriptions.get(e);if(!s)throw Error(`Subscription not found: ${e}`);if(await s.pending("subscribed"),"subscribed"!==s.intent)throw Error(`Subscription is closed: ${e}`);let n=s.remoteId,r={id:n,action:t,payload:i};this.logger.debug("perform",r);try{let e=await this.protocol.perform(n,t,i);return e&&this.logger.debug("perform result",{message:e,request:r}),e}catch(o){throw this.logger.error("perform failed",{error:o,request:r}),o}}on(e,t){return this.emitter.on(e,t)}once(e,t){let i=this.emitter.on(e,((...e)=>{i(),t(...e)}));return i}emit(e,...t){return this.emitter.emit(e,...t)}pendingConnect(){return this._pendingConnect||(this._pendingConnect=new Promise(((e,t)=>{let i=[()=>delete this._pendingConnect];i.push(this.on("connect",(()=>{i.forEach((e=>e())),e()}))),i.push(this.on("close",(e=>{i.forEach((e=>e())),t(e)}))),i.push(this.on("disconnect",(e=>{i.forEach((e=>e())),t(e)})))}))),this._pendingConnect}}var m=i(92925);let f=0;class w{constructor(e={}){let{logger:t}=e;this.logger=t||new l,this.pendingSubscriptions={},this.pendingUnsubscriptions={},this.subscribeCooldownInterval=e.subscribeCooldownInterval||250,this.subscribeRetryInterval=e.subscribeRetryInterval||5e3}attached(e){this.cable=e}subscribe(e,t){let i={channel:e};t&&Object.assign(i,t);let s=(0,m.I)(i);if(this.pendingUnsubscriptions[s]){let i=1.5*this.subscribeCooldownInterval;return this.logger.debug(`unsubscribed recently, cooldown for ${i}`,s),new Promise((s=>{setTimeout((()=>{s(this.subscribe(e,t))}),i)}))}if(this.pendingSubscriptions[s])return this.logger.warn("subscription is already pending, skipping",s),Promise.reject(Error("Already subscribing"));let n=this.subscribeRetryInterval;return new Promise(((e,t)=>{let i=++f;this.pendingSubscriptions[s]={resolve:e,reject:t,id:i},this.cable.send({command:"subscribe",identifier:s}),this.maybeRetrySubscribe(i,s,n)}))}maybeRetrySubscribe(e,t,i){setTimeout((()=>{let s=this.pendingSubscriptions[t];s&&s.id===e&&(this.logger.warn(`no subscription ack received in ${i}ms, retrying subscribe`,t),this.cable.send({command:"subscribe",identifier:t}),this.maybeExpireSubscribe(e,t,i))}),i)}maybeExpireSubscribe(e,t,i){setTimeout((()=>{let s=this.pendingSubscriptions[t];s&&s.id===e&&(delete this.pendingSubscriptions[t],s.reject(new c.bk(`Haven't received subscription ack in ${2*i}ms for ${t}`)))}),i)}unsubscribe(e){return this.cable.send({command:"unsubscribe",identifier:e}),this.pendingUnsubscriptions[e]=!0,setTimeout((()=>{delete this.pendingUnsubscriptions[e]}),this.subscribeCooldownInterval),Promise.resolve()}perform(e,t,i){return i||(i={}),i.action=t,this.cable.send({command:"message",identifier:e,data:JSON.stringify(i)}),Promise.resolve()}receive(e){if("object"!==typeof e)return void this.logger.error("unsupported message format",{message:e});let{type:t,identifier:i,message:s,reason:n,reconnect:r}=e;if("ping"===t)return this.cable.keepalive(e.message);if("welcome"===t)return this.cable.connected();if("disconnect"===t){let e=new c.lZ(n);return this.reset(e),void(!1===r?this.cable.closed(e):this.cable.disconnected(e))}if("confirm_subscription"===t){let e=this.pendingSubscriptions[i];return e?(delete this.pendingSubscriptions[i],e.resolve(i)):(this.logger.error("subscription not found, unsubscribing",{type:t,identifier:i}),void this.unsubscribe(i))}if("reject_subscription"===t){let e=this.pendingSubscriptions[i];return e?(delete this.pendingSubscriptions[i],e.reject(new c.RB)):this.logger.error("subscription not found",{type:t,identifier:i})}if(s)return{identifier:i,message:s};this.logger.warn(`unknown message type: ${t}`,{message:e})}reset(e){for(let t in this.pendingSubscriptions)this.pendingSubscriptions[t].reject(e);this.pendingSubscriptions={}}recoverableClosure(){return!1}}class v{encode(e){return JSON.stringify(e)}decode(e){try{return JSON.parse(e)}catch(t){}}}class y{constructor(e,t={}){this.url=e;let i=t.websocketImplementation;if(i)this.Impl=i;else{if("undefined"===typeof WebSocket)throw new Error("No WebSocket support");this.Impl=WebSocket}this.connected=!1,this.emitter=(0,s.i)();let{format:n,subprotocol:r}=t;this.format=n||"text",this.connectionOptions=t.websocketOptions,this.subprotocol=r}open(){return this.connectionOptions?this.ws=new this.Impl(this.url,this.subprotocol,this.connectionOptions):this.ws=new this.Impl(this.url,this.subprotocol),this.ws.binaryType="arraybuffer",this.initListeners(),new Promise(((e,t)=>{let i=[];i.push(this.once("open",(()=>{i.forEach((e=>e())),e()}))),i.push(this.once("close",(()=>{i.forEach((e=>e())),t(Error("WS connection closed"))})))}))}setURL(e){this.url=e}set(){}send(e){if(!this.ws||!this.connected)throw Error("WebSocket is not connected");this.ws.send(e)}close(){this.ws&&this.connected&&this.onclose()}on(e,t){return this.emitter.on(e,t)}once(e,t){let i=this.emitter.on(e,((...e)=>{i(),t(...e)}));return i}initListeners(){this.ws.onerror=e=>{this.emitter.emit("error",e.error||new Error("WS Error"))},this.ws.onclose=()=>{this.onclose()},this.ws.onmessage=e=>{let t=e.data;"binary"===this.format&&(t=new Uint8Array(t)),this.emitter.emit("data",t)},this.ws.onopen=()=>{this.connected=!0,this.emitter.emit("open")}}onclose(){this.ws.onclose=void 0,this.ws.close(),delete this.ws,this.connected=!1,this.emitter.emit("close")}}const _={maxMissingPings:2,maxReconnectAttempts:1/0},I=()=>Date.now(),E=(e,t)=>{t=t||{};let{backoffRate:i,jitterRatio:s,maxInterval:n}=t;return i=i||2,void 0===s&&(s=.5),t=>{let r=e*i**t,o=r+(r*i-r)*Math.random();return o*=1+2*(Math.random()-.5)*s,n&&n<o&&(o=n),o}};class k{constructor({pingInterval:e,...t}){if(this.pingInterval=e,!this.pingInterval)throw Error(`Incorrect pingInterval is provided: ${e}`);if(t=Object.assign({},_,t),this.strategy=t.reconnectStrategy,!this.strategy)throw Error("Reconnect strategy must be provided");this.maxMissingPings=t.maxMissingPings,this.maxReconnectAttempts=t.maxReconnectAttempts,this.logger=t.logger||new l,this.state="pending_connect",this.attempts=0,this.disconnectedAt=I()}watch(e){this.target=e,this.initListeners()}reconnectNow(){return"connected"!==this.state&&"pending_connect"!==this.state&&"closed"!==this.state&&(this.cancelReconnect(),this.state="pending_connect",this.target.connect().catch((e=>{this.logger.info("Failed at reconnecting: "+e)})),!0)}initListeners(){this.unbind=[],this.unbind.push(this.target.on("connect",(()=>{this.attempts=0,this.pingedAt=I(),this.state="connected",this.cancelReconnect(),this.startPolling()}))),this.unbind.push(this.target.on("disconnect",(()=>{this.disconnectedAt=I(),this.state="disconnected",this.stopPolling(),this.scheduleReconnect()}))),this.unbind.push(this.target.on("close",(()=>{this.disconnectedAt=I(),this.state="closed",this.cancelReconnect(),this.stopPolling()}))),this.unbind.push(this.target.on("keepalive",(()=>{this.pingedAt=I()}))),this.unbind.push((()=>{this.cancelReconnect(),this.stopPolling()}))}dispose(){delete this.target,this.unbind&&this.unbind.forEach((e=>e())),delete this.unbind}startPolling(){this.pollId&&clearTimeout(this.pollId);let e=this.pingInterval+(Math.random()-.5)*this.pingInterval*.5;this.pollId=setTimeout((()=>{this.checkStale(),"connected"===this.state&&this.startPolling()}),e)}stopPolling(){this.pollId&&clearTimeout(this.pollId)}checkStale(){let e=I()-this.pingedAt;e>this.maxMissingPings*this.pingInterval&&(this.logger.warn(`Stale connection: ${e}ms without pings`),this.state="pending_disconnect",this.target.disconnected(new c.An))}scheduleReconnect(){if(this.attempts>=this.maxReconnectAttempts)return void this.target.close();let e=this.strategy(this.attempts);this.attempts++,this.logger.info(`Reconnecting in ${e}ms (${this.attempts} attempt)`),this.state="pending_reconnect",this.reconnnectId=setTimeout((()=>this.reconnectNow()),e)}cancelReconnect(){this.reconnnectId&&(clearTimeout(this.reconnnectId),delete this.reconnnectId)}}const S={protocol:"actioncable-v1-json",pingInterval:3e3,maxReconnectAttempts:1/0,maxMissingPings:2,logLevel:"warn",lazy:!0};function R(e,t){if("object"===typeof e&&"undefined"===typeof t&&(t=e,e=void 0),t=t||{},!e&&!t.transport)throw Error("URL or transport must be specified");t=Object.assign({},S,t);let{protocol:i,websocketImplementation:s,websocketFormat:n,websocketOptions:r,logLevel:o,logger:c,transport:h,encoder:d,lazy:a,monitor:u,pingInterval:g,reconnectStrategy:b,maxMissingPings:m,maxReconnectAttempts:f,subprotocol:_,tokenRefresher:I}=t;if(c=c||new l(o),"string"===typeof i&&(_=_||i),"actioncable-v1-json"===i)i=new w({logger:c}),d=d||new v,n=n||"text";else if("actioncable-v1-msgpack"===i){if(i=new w({logger:c}),n="binary",!d)throw Error("Msgpack encoder must be specified explicitly. Use `@anycable/msgpack-encoder` package or build your own")}else if("actioncable-v1-protobuf"===i){if(i=new w({logger:c}),n=n||"binary",!d)throw Error("Protobuf encoder must be specified explicitly. Use `@anycable/protobuf-encoder` package or build your own")}else if("string"===typeof i)throw Error(`Protocol is not supported yet: ${i}`);if(!i)throw Error("Protocol must be specified");h=h||new y(e,{websocketImplementation:s,websocketOptions:r,subprotocol:_,format:n}),b=b||E(g),!1!==u&&(u=u||new k({pingInterval:g,reconnectStrategy:b,maxMissingPings:m,maxReconnectAttempts:f,logger:c}));let R=new p({protocol:i,transport:h,encoder:d,logger:c,lazy:a});return u&&(u.watch(R),R.monitor=u),I&&function(e,t){let i=!1;e.on("connect",(()=>i=!1)),e.on("close",(async s=>{s&&(i?e.logger.warn("Token auto-refresh is disabled",s):"token_expired"===s.reason&&(i=!0,await t()))}))}(R,(async()=>{try{await I(h)}catch(e){return c.error("Failed to refresh authentication token: "+e),!1}return R.connect().catch((()=>{})),!0})),R}class x extends d{writeLogEntry(e,t,i){i?console[e](t,i):console[e](t)}}class P extends k{watch(e){super.watch(e),this.initActivityListeners()}initActivityListeners(){if("undefined"!==typeof document&&"undefined"!==typeof window&&document.addEventListener&&window.addEventListener){let e=()=>{document.hidden||this.reconnectNow()&&this.logger.debug("Trigger reconnect due to visibility change")},t=e=>{this.reconnectNow()&&this.logger.debug("Trigger reconnect",{event:e})},i=()=>this.disconnect(new c.lZ("page_frozen"));document.addEventListener("visibilitychange",e,!1),window.addEventListener("focus",t,!1),window.addEventListener("online",t,!1),window.addEventListener("resume",t,!1),window.addEventListener("freeze",i,!1),this.unbind.push((()=>{document.removeEventListener("visibilitychange",e,!1),window.removeEventListener("focus",t,!1),window.removeEventListener("online",t,!1),window.removeEventListener("resume",t,!1),window.removeEventListener("freeze",i,!1)}))}}disconnect(e){"disconnected"!==this.state&&"closed"!==this.state&&(this.logger.info("Disconnecting",{reason:e.message}),this.cancelReconnect(),this.stopPolling(),this.state="pending_disconnect",this.target.disconnected(e))}}const L=["cable","action-cable"],C=(e,t)=>{for(let i of L){let s=e.head.querySelector(`meta[name='${i}-${t}']`);if(s)return s.getAttribute("content")}},T=e=>{if(e.match(/wss?:\/\//))return e;if("undefined"!==typeof window){return`${window.location.protocol.replace("http","ws")}//${window.location.host}${e}`}return e};function A(e,t){"object"===typeof e&&"undefined"===typeof t&&(t=e,e=void 0),e=e||(()=>{if("undefined"!==typeof document&&document.head){let e=C(document,"url");if(e)return T(e)}return T("/cable")})(),t=t||{},t=Object.assign({},S,t);let{logLevel:i,logger:s,pingInterval:n,reconnectStrategy:r,maxMissingPings:o,maxReconnectAttempts:c}=t;return s=t.logger=t.logger||new x(i),r=t.reconnectStrategy=t.reconnectStrategy||E(n),!1!==t.monitor&&(t.monitor=t.monitor||new P({pingInterval:n,reconnectStrategy:r,maxMissingPings:o,maxReconnectAttempts:c,logger:s})),R(e,t)}var $=A()}}]);