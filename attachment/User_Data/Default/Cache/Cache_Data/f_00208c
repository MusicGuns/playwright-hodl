const contractAttributes = [
  "acceptorLogin", "adminConfirmedRefund", "adminConfirmedRelease", "blockchain",
  "borrowerAccepted", "borrowerConfirmedEscrow", "borrowerRefundAddress",
  "canceledBy", "canceledFrom", "cancellationReason", "completedWith",
  "confirmationsRequired", "currencyCode", "depositTimeoutOccured", "disputeStartedAt",
  "disputedBy", "disputedFrom", "disputeReason", "escrowReleaseApproved", "escrowXpubIndex",
  "lenderAccepted", "lenderConfirmedEscrow", "toBeRepaid", "releasePrice",
  "lenderReleaseAddress", "offerorLogin", "repaymentTransactionLinks",
  "paymentConfirmed", "totalConfirmedPaymentAmount", "paymentTransactionLinks",
  "paymentAddress", "paymentConfirmationTimeoutOccured", "paymentTimeoutOccured", "paymentTransactionLink",
  "paymentWindow", "paymentWindowExpired", "expired", "repaymentWindowExpired", "period",
  "repaymentAddress", "repaymentTimeoutOccured", "status",
  "contractValue", "leftToRepay", "leftToRepayBtc", "repaymentConfirmationTimeoutOccured",
  "multisigIndex", "escrowAddress", "escrowRedeemScript"
];

const dateContractAttributes = [
  "createdAt", "depositedAt", "escrowConfirmedAt", "paidAt", "repaidAt", "paymentConfirmedAt", "repaymentConfirmedAt",
  "repaymentStartedAt", "expiresAt", "disputeStartedAt", "canceledAt", "completedAt"
];

const decimalContractAttributes = [
  "contractVolume", "collateralVolume", "currentLtv", "forcedLiquidationBtcPrice", "interestRate",
  "ltvRatio", "originationFee", "price", "toBeDeposited",
  "transactionFee",
]

const ajaxAttributes = ["borrowerLogin", "counterpartyLogin", "lenderLogin", "side"];

const dataAttributes = [
  "acceptanceWindow", "blockchainExplorer", "clientXpub", "depositingWindow",
  "encryptedSeed", "id", "ltvMarginCallFirst", "ltvMarginCallSecond", "ltvMarginCallThird",
  "ltvForcedLiquidation", "paymentWindow", "paymentConfirmationWindow",
  "repaymentWindow", "repaymentConfirmationWindow",
  "userLogin", "multisigIndex", "escrowRedeemScript", "escrowAddress"
];

const contractPage = new Vue({
  el: "#contract",

  data() {
    return {
      acceptContractWindowVisible: false,
      action: null,
      chatHistory: [],
      decryptedSeed: null,
      cancelContractQuestionnarie: false,
      isLoading: true,
      otpConfirmationCancelContractWindowVisible: false,
      otpConfirmationWindowVisible: false,
      paymentConfirmationWindowVisible: false,
      paymentPasswordConfirmationModalVisible: false,
      paymentPasswordModalVisible: false,
      paymentTransactionLinkWindowVisible: false,
      popupMessageText: null,
      popupMessageVisible: false,
      popupMessageSuccess: false,
      refundWindowVisible: false,
      refundTransactionsListVisible: false,
      releaseTransactions: [],
      releaseOutputsListVisible: false,
      releaseWindowVisible: false,
      repaymentTransactionLinkWindowVisible: false,
      userEnabled2fa: null,
      locales: {},
      transactionLinkId: null,
      transactions: [],
      transactionsListVisible: false,
      transactionsUpdaterStarted: false,
      transactionsUpdaterTimeLeft: 0,
      updateRepaymentAddressWindowVisible: false,
      updateRefundAddressWindowVisible: false,
      updateReleaseAddressWindowVisible: false,
      downloadBackupModalVisible: false,
      objectType: 'contract',
      ...[...dataAttributes, ...contractAttributes, ...decimalContractAttributes, ...dateContractAttributes, ...ajaxAttributes].reduce(
        (mem, current) => { mem[current] = null; return mem; },
      {}),
      voteRequired: true,
    };
  },

  filters: {
    formatBtcAmount: function(value) {
      return value.toFixed(8);
    },

    inUserTimezone: function(value) {
      const options = {
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        month: 'numeric',
        year: 'numeric',
      }

      return new Date(value).toLocaleString([], options).replace(/,/g, '');
    },
  },

  async mounted() {
    try {
      const { data: { contract: attributes } } =
        await this.$http.get(`/contracts/${this.$el.dataset.id}`);

      this.updateAjaxContractAttributes(attributes);

      dataAttributes.forEach(attribute => {
        return this[camelize(attribute)] = nullifyEmpty(this.$el.dataset[attribute]);
      });

      Object.keys(this.$el.dataset)
            .filter(key => key.startsWith('locales_'))
            .map(key => [key, key.replace("locales_", "")])
            .forEach(([key, msgKey]) => this.$set(this.locales, msgKey, this.$el.dataset[key]));

      const subscribe = () => {
        window.cable.subscriptions.create({
          channel: `contract`,
          contract_id: this.id,
        }, {
          connected: (data) => {
            console.log(`Connected to WS for contract ${this.id}`);
          },
          received: (data) => {
            console.log(`Received data for contract ${this.id}`);
            console.log(data);
            this.updateContractAttributes(data.contract);
          },
          disconnected: () => {
            console.log(`Disconnected from WS for contract ${this.id}`);
          },
          rejected() {
            console.log(`Rejected WS connection to contract ${this.id}`);
          },
        });
      };

      if (window.cable == null) {
        window.addEventListener('websocketReady', subscribe);
      } else {
        subscribe();
      }
    } finally {
      this.isLoading = false;
    }
  },

  computed: {
    adminRefundConfirmationNeeded() {
      return [
        () => {
          return ['dispute_payment_links', 'dispute_repayment_links'].includes(this.canceledFrom) &&
                 this.status === 'canceled' &&
                 this.hasUnspents &&
                 !this.adminConfirmedRefund &&
                 !this.adminConfirmedRelease;
        },

        () => {
          return this.stateIn('forcedLiquidation') &&
                 this.hasUnspents &&
                 !this.adminConfirmedRefund &&
                 !this.adminConfirmedRelease;
        }
      ].some(x => x());
    },

    adminReleaseConfirmationNeeded() {
      return [
        () => {
          return ['dispute_repayment_links', 'dispute_payment_links'].includes(this.canceledFrom) &&
                 this.status === 'canceled' &&
                 this.hasUnspents &&
                 !this.adminConfirmedRefund &&
                 !this.adminConfirmedRelease;
        },

        () => {
          return this.stateIn('forcedLiquidation') &&
                 this.hasUnspents &&
                 !this.adminConfirmedRefund &&
                 !this.adminConfirmedRelease;
        },
      ].some(x => x());
    },

    canCancel() {
      return [
        () => {
          return ['dispute_payment_links', 'dispute_repayment_links'].includes(this.status) && this.currentUserRole == 'admin'
        },

        () => {
          return ![
            "canceled",
            "completed",
            "dispute",
            "payment",
            "forced_liquidation",
            "in_progress",
            "repayment"
          ].includes(this.displayStatus) && this.currentUserRole == 'admin';
        },

        () => {
          return [
            "pendingNoPaymentPassword",
            "pendingNotAccepted",
            "pendingAccepted",
            "pendingEscrowNotConfirmed",
            "pendingEscrowConfirmedByCurrentUser",
          ].includes(this.state);
        },

        () => {
          return [
            "depositingEscrowNotFunded",
            "depositingNotEnoughFunds",
            "depositingNotEnoughConfirmations"
          ].includes(this.state) && this.currentUserRole === "borrower";
        },

        () => {
          return [
            "depositingEscrowNotFunded",
            "depositingNotEnoughFunds",
            "depositingNotEnoughConfirmations"
          ].includes(this.state) && this.currentUserRole === "lender" && this.depositTimeoutOccured;
        },
      ].some(x => x());
    },

    canArrangePaymentLinks() {
      return [
        "disputePaymentLinks",
      ].includes(this.state);
    },

    canArrangeRepaymentLinks() {
      return [
        "disputeRepaymentLinks",
      ].includes(this.state);
    },

    canForceContractLiquidation() {
      return [
        () => {
          return this.state === 'disputeRepaymentLinks' &&
                 this.currentUserRole == 'admin';
        },
      ].some(x => x());
    },

    canRefund() {
      const rules = [
        () => {
          return ['depositing'].includes(this.canceledFrom) &&
          this.status === "canceled" &&
          this.currentUserRole === "borrower" &&
          this.hasUnspents;
        },

        () => {
          return [
            'dispute_payment_links',
            'dispute_repayment_links',
          ].includes(this.canceledFrom) &&
          this.status === "canceled" &&
          this.currentUserRole === "borrower" &&
          this.hasUnspents &&
          this.adminConfirmedRefund;
        },

        () => {
          return this.status === "forced_liquidation" &&
                 this.currentUserRole === "borrower" &&
                 this.adminConfirmedRefund &&
                 this.hasUnspents;
        },

        () => {
          return this.status == "completed" &&
                 ["repayment", "repayment"].includes(this.completedWith) &&
                 this.currentUserRole == "borrower" &&
                 this.hasUnspents;
        },
      ]

      return rules.some(f => f());
    },

    canRelease() {
      const rules = [
        () => {
          return [
            'dispute_payment_links',
            'dispute_repayment_links',
          ].includes(this.canceledFrom) &&
          this.status === "canceled" &&
          ["lender", "borrower"].includes(this.currentUserRole) &&
          this.hasUnspents &&
          this.adminConfirmedRelease;
        },

        () => { return this.stateIn('repaymentEscrowReleaseApproved'); },

        () => {
          return this.stateIn('forcedLiquidationAdminConfirmedRelease') &&
                 this.currentUserRole &&
                 this.adminConfirmedRelease &&
                 this.hasUnspents;
        },
      ]

      return rules.some(f => f());
    },

    canStartDispute() {
      const rules = [
        () => {
          return [
            'payment',
            'paymentPaid',
            'inProgress',
            'repayment',
            'repaymentPaid',
          ].includes(this.state) && this.currentUserRole == 'admin'
        },

        () => {
          return this.state == 'payment' &&
            ['lender', 'borrower'].includes(this.currentUserRole) &&
            this.paymentTimeoutOccured
        },

        () => {
          return this.state == 'paymentPaid' &&
            ['lender', 'borrower'].includes(this.currentUserRole) &&
            this.paymentConfirmationTimeoutOccured
        },

        () => {
          return this.state == 'repayment' &&
            ['lender', 'borrower'].includes(this.currentUserRole) &&
            this.repaymentTimeoutOccured
        },

        () => {
          return this.state == 'repaymentPaid' &&
            ['lender', 'borrower'].includes(this.currentUserRole) &&
            this.repaymentConfirmationTimeoutOccured
        },
      ]

      return rules.some(f => f());
    },

    counterpartyAccepted() {
      return this[`${this.counterpartyRole}Accepted`];
    },

    counterpartyConfirmedEscrow() {
      return this[`${this.counterpartyRole}ConfirmedEscrow`];
    },

    counterpartyRole() {
      if (this.side == "lend") return "borrower";
      if (this.side == "borrow") return "lender";
    },

    currentLtvClass() {
      const convertedCurrentLtv = this.currentLtv.mul(100).toFixed();
      if (convertedCurrentLtv < this.ltvMarginCallFirst) {
        return "green"
      }
      else if ((convertedCurrentLtv > this.ltvMarginCallFirst) && (convertedCurrentLtv < this.ltvMarginCallSecond)) {
        return "yellow"
      } else if (convertedCurrentLtv > this.ltvMarginCallThird) {
        return "red"
      } else {
        return ""
      }
    },

    currentUserAccepted() {
      return this[`${this.currentUserRole}Accepted`]
    },

    currentUserConfirmedEscrow() {
      return this[`${this.currentUserRole}ConfirmedEscrow`];
    },

    currentUserHasPaymentPassword() {
      return this.encryptedSeed != null && this.clientXpub != null;
    },

    currentUserBaseRole() {
      if (this.userLogin == this.acceptorLogin) return "acceptor";
      else return "offeror"
    },

    currentUserRole() {
      if (this.side == "lend") return "lender";
      if (this.side == "borrow") return "borrower";
      if (this.side == "admin") return "admin"
    },

    displayStatus() {
      if (/^payment/.test(this.status)) return 'payment'
      if (/^repayment/.test(this.status)) return 'repayment'
      if (/^dispute/.test(this.status)) return 'dispute'
      return this.status;
    },

    escrowHasEnoughFunds() {
      if (this.toBeDeposited == null || this.totalAmountDepositedConfirmed == null) return false;

      return this.totalAmountDeposited.gte(this.toBeDeposited);
    },

    escrowHasEnoughConfirmations() {
      return this.minTransactionConfirmations >= this.confirmationsRequired;
    },

    escrowNeedsToDepositAmount() {
      return (this.toBeDeposited - this.totalAmountDeposited).toFixed(8);
    },

    escrowReleaseTransactions() {
      return this.releaseTransactions.filter(x => x.destination == "release" && x.broadcasted);
    },

    hasRefunds() {
      return this.refundTransactions.length > 0;
    },

    hasTransactions() {
      return this.transactions.length > 0;
    },

    hasMeaningPaymentTransactionLinks() {
      return this.paymentTransactionLinks.some(x => x.status == 'pending' || x.status == 'confirmed')
    },

    hasMeaningRepaymentTransactionLinks() {
      return this.repaymentTransactionLinks.some(x => x.status == 'pending' || x.status == 'confirmed')
    },

    hasUnspents() {
      return this.totalAmountUnspent.gt(0);
    },

    minTransactionConfirmations() {
      return Math.min(...this.transactions.map(tx => tx.confirmations));
    },

    paymentPasswordAction() {
      return this.currentUserHasPaymentPassword ? "update" : "create";
    },

    refundTransactions() {
      return this.releaseTransactions.filter(x => x.destination == "refund" && x.broadcasted);
    },

    showCompletedDepositingForcedLiquidationContracts() {
      return [
        "depositingNotEnoughConfirmations",
        "depositingNotEnoughFunds",
        "forcedLiquidationAdminConfirmedRefund",
        "forcedLiquidationAdminConfirmedRelease",
      ].includes(this.state);
    },

    showBorrowerRefundAddressAndPaymentBlock() {
      return this.currentUserRole !== 'borrower' && ([
        "inProgress",
      ].includes(this.state) || this.displayStatus === 'dispute');
    },

    showDepositing() {
      return [ "depositingNotEnoughConfirmations", "depositingNotEnoughFunds"].includes(this.state) && this.currentUserRole == 'admin';
    },

    showLenderReleaseAddress() {
      return this.displayStatus === "dispute" && this.currentUserRole === "borrower";
    },

    showPaymentAmount() {
      return [ "payment", "depositing" ].includes(this.displayStatus);
    },

    showPaymentAmountAdmin() {
      return [ "payment", "depositing", "dispute" ].includes(this.displayStatus) && this.currentUserRole;
    },

    showPaymentInfo() {
      return this.displayStatus === 'payment';
    },

    showPaymentInDisputeOrPayment() {
      return ['dispute', 'payment'].includes(this.displayStatus) && this.currentUserRole;
    },

    showRepaymentAddressInfo() {
      return [
        "inProgress",
        "forcedLiquidation",
      ].includes(this.state) || ['dispute', 'repayment'].includes(this.displayStatus)
    },

    showRepaymentAddressInfoAdmin() {
      return this.currentUserRole == 'admin'
    },

    showUncompletedDepositingForcedLiquidationContracts() {
      return ![
        "depositingNotEnoughConfirmations",
        "depositingNotEnoughFunds",
        "forcedLiquidationAdminConfirmedRefund",
        "forcedLiquidationAdminConfirmedRelease",
        "repaymentEscrowReleaseApproved"
      ].includes(this.state) && this.status !== 'completed';
    },

    showUncompletedDepositingAndRepayment() {
      return ![
        "depositingNotEnoughConfirmations",
        "depositingNotEnoughFunds",
        "repaymentEscrowReleaseApproved"
      ].includes(this.state) && this.status !== 'completed' && this.currentUserRole == 'admin';
    },

    state() {
      newState = defineState(this);
      console.log(`State updated. New state: ${newState}`)
      return newState;
    },

    contractValueNumeric() {
      return parseDecoratedNumeric(this.contractValue)
    },

    totalConfirmedPaymentAmountNumeric() {
      return parseDecoratedNumeric(this.totalConfirmedPaymentAmount)
    },

    leftToRepayNumeric() {
      return parseDecoratedNumeric(this.leftToRepay)
    },

    totalAmountDeposited() {
      return this.transactions.reduce((sum, tx) => sum.plus(tx.amount), new Big(0));
    },

    totalAmountDepositedConfirmed() {
      return this.transactions.filter(tx => tx.confirmations >= this.confirmationsRequired)
                              .reduce((sum, tx) => sum.plus(tx.amount), new Big(0));
    },

    totalAmountRefunded() {
      return this.refundTransactions.reduce((sum, tx) => sum.plus(tx.amount), new Big(0));
    },

    totalAmountReleased() {
      return this.releaseTransactions
        .filter(x => x.broadcasted)
        .reduce((sum, tx) => sum.plus(tx.amount).plus(tx.transactionFee), new Big(0));
    },

    totalAmountUnspent() {
      return this.totalAmountDeposited.minus(this.totalAmountReleased);
    },

    withPaymentAddress() {
      return ['dispute', 'payment'].includes(this.displayStatus)
    },

    withRepaymentAddress() {
      return [
        "inProgress",
        "repayment",
      ].includes(this.state);
    },
  },

  methods: {
    async acceptContract(attributes = {}) {
      const { data } = await this.$http.post(`/contracts/${this.id}/accept`, {
        _csrf_token: this.csrfToken(),
        contract: {
          borrower_refund_address: attributes.borrowerRefundAddress,
          lender_release_address: attributes.lenderReleaseAddress,
          repayment_address: attributes.repaymentAddress,
          payment_address: attributes.paymentAddress,
        },
      });

      if (data.success) {
        this.hideAcceptContractWindow();
      } else {
        this.showPopupMessage(data.error);
      }
    },

    async approveEscrowRelease() {
      await this.$http.post(`/contracts/${this.id}/approve_escrow_release`, {
        _csrf_token: this.csrfToken(),
      });
    },

    async cancelContract() {
      const { data } = await this.$http.post(`/contracts/${this.id}/cancel`, {
        _csrf_token: this.csrfToken(),
      });

      if (!data.success) this.showPopupMessage(data.error);
    },

    async fetchUserEnabled2fa() {
      const { data } = await this.$http.get(`/users/enabled_2fa`, {
        credentials: true
      });

      this.userEnabled2fa = data.enabled;
    },

    async cancelContractRequest() {
      this.action = 'confirm_cancel';
      await this.fetchUserEnabled2fa();
      this.otpConfirmationCancelContractWindowVisible = true;
    },

    async checkDepositTransactions() {
      const { data: { contract } } = await this.$http.get(`/contracts/${this.id}/check_deposit_transactions`);
      this.updateAjaxContractAttributes(contract);
    },

    async checkTransactions() {
      const { data: { contract } } = await this.$http.get(`/contracts/${this.id}/check_transactions`);
      this.updateAjaxContractAttributes(contract);
    },

    async confirmEscrow(escrowValid) {
      return await this.$http.post(`/contracts/${this.id}/confirm_escrow`, {
        _csrf_token: this.csrfToken(),
        escrow_valid: escrowValid,
      });
    },

    async confirmRepayment() {
      const response = await this.$http.post(`/contracts/${this.id}/confirm_repayment_paid`, {
        _csrf_token: this.csrfToken(),
      })
    },

    async arrangePaymentLinksByAdmin() {
      const response = await this.$http.post(`/contracts/${this.id}/admin/arrange_payment_links`, {
        _csrf_token: this.csrfToken(),
      });
    },

    async arrangeRepaymentLinksByAdmin() {
      const response = await this.$http.post(`/contracts/${this.id}/admin/arrange_repayment_links`, {
        _csrf_token: this.csrfToken(),
      });
    },

    async confirmRefundByAdmin() {
      const { data } = await this.$http.post(`/contracts/${this.id}/admin/confirm_refund`, {
        _csrf_token: this.csrfToken(),
      });

      if (!data.success) this.showPopupMessage(data.error);
    },

    async confirmRefundRequestByAdmin() {
      this.showOtpConfirmationModal('admin_confirm_refund');
    },

    async confirmReleaseByAdmin() {
      const { data } = await this.$http.post(`/contracts/${this.id}/admin/confirm_release`, {
        _csrf_token: this.csrfToken(),
      });

      if (!data.success) this.showPopupMessage(data.error);
    },

    async confirmReleaseRequestByAdmin() {
      this.showOtpConfirmationModal('admin_confirm_release');
    },

    async fetchNewDepositTransactions() {
      try {
        await this.checkDepositTransactions();
        if (!this.escrowHasEnoughConfirmations) {
          this.startTransactionsUpdater(this.checkDepositTransactions);
        } else {
          this.showPopupMessage(this.locales['no_funds_detected']);
        }
      } catch(e) {
          this.startTransactionsUpdater(this.checkDepositTransactions);
      }
    },

    async fetchNewTransactions() {
      try {
        await this.checkTransactions();
        if (!this.escrowHasEnoughConfirmations) {
          this.startTransactionsUpdater(this.checkTransactions);
        } else {
          this.showPopupMessage(this.locales['no_funds_detected']);
        }
      } catch(e) {
        this.startTransactionsUpdater(this.checkTransactions);
      }
    },

    async fetchNewTransactionsFromCanceled() {
      await this.checkTransactions();

      if (!this.hasTransactions) {
        this.showPopupMessage(this.locales['no_funds_detected']);
      }
    },

    async forceContractExpiration() {
      await this.$http.post(`/contracts/${this.id}/force_expiration`, {
        _csrf_token: this.csrfToken(),
      });
    },

    async forceContractLiquidation() {
      const { data } = await this.$http.post(`/contracts/${this.id}/force_liquidation`, {
        _csrf_token: this.csrfToken(),
      });

      if (!data.success) this.showPopupMessage(data.error);
    },

    forceContractLiquidationRequest() {
      this.showOtpConfirmationModal('confirm_forced_liquidation');
    },

    async adminDecidesCreatePaymentLink() {
      this.showOtpConfirmationModal('admin_create_payment_link')
    },

    async adminDecidesUpdatePaymentLink(event) {
      this.extractTransactionLinkId(event)
      this.showOtpConfirmationModal('admin_update_payment_link')
    },

    async adminDecidesDestroyPaymentLink(event) {
      this.extractTransactionLinkId(event)
      this.showOtpConfirmationModal('admin_destroy_payment_link')
    },

    async adminDecidesCreateRepaymentLink() {
      this.showOtpConfirmationModal('admin_create_repayment_link')
    },

    async adminDecidesUpdateRepaymentLink(event) {
      this.extractTransactionLinkId(event)
      this.showOtpConfirmationModal('admin_update_repayment_link')
    },

    async adminDecidesDestroyRepaymentLink(event) {
      this.extractTransactionLinkId(event)
      this.showOtpConfirmationModal('admin_destroy_repayment_link')
    },

    extractTransactionLinkId(event) {
      this.transactionLinkId = +event.target.id.replace(/\D/g, '')
    },

    extractTransactionLinkAttributes(prefix) {
      return {
        url: document.getElementById(`${prefix}Url`).value,
        amount: +document.getElementById(`${prefix}Amount`).value,
        admin_comment: document.getElementById(`${prefix}AdminComment`).value,
        status: document.getElementById(`${prefix}Status`).value,
      }
    },

    async adminCreatePaymentLink() {
      try {
        const { data } = await this.$http.post(`/contracts/${this.id}/payment_links`, {
          _csrf_token: this.csrfToken(),
          ...this.extractTransactionLinkAttributes('newPaymentLink'),
        })

        if (data.success) {
          this.showPopupMessage('Admin created payment link successfuly', true)
          this.updateContractAttributes(data.contract)
          document.querySelectorAll('input[id^="newPaymentLink"]').forEach(i => i.value = '')
        }
      } catch({ response: { data: { error } = {} } = {} }) {
        this.showPopupMessage(error || 'Something went wrong')
      }
    },

    async adminUpdatePaymentLink() {
      try {
        const { data } = await this.$http.patch(`/contracts/${this.id}/payment_links/${this.transactionLinkId}`, {
          _csrf_token: this.csrfToken(),
          ...this.extractTransactionLinkAttributes(`transactionLink${this.transactionLinkId}`),
        })

        if (data.success) {
          this.showPopupMessage('Admin updated payment link successfuly', true)
          this.updateContractAttributes(data.contract)
        }
      } catch({ response: { data: { error } = {} } = {} }) {
        this.showPopupMessage(error || 'Something went wrong')
      }
    },

    async adminDestroyPaymentLink() {
      try {
        const { data } = await this.$http.patch(`/contracts/${this.id}/payment_links/${this.transactionLinkId}/destroy`, {
          _csrf_token: this.csrfToken(),
          ...this.extractTransactionLinkAttributes(`transactionLink${this.transactionLinkId}`),
        })

        if (data.success) {
          this.showPopupMessage('Admin destroyed payment link successfuly', true)
          this.updateContractAttributes(data.contract)
        }
      } catch({ response: { data: { error } = {} } = {} }) {
        this.showPopupMessage(error || 'Something went wrong')
      }
    },

    async adminCreateRepaymentLink() {
      try {
        const { data } = await this.$http.post(`/contracts/${this.id}/repayment_links`, {
          _csrf_token: this.csrfToken(),
          ...this.extractTransactionLinkAttributes('newRepaymentLink'),
        })

        if (data.success) {
          this.showPopupMessage('Admin created repayment link successfuly', true)
          this.updateContractAttributes(data.contract)
          document.querySelectorAll('input[id^="newRepaymentLink"]').forEach(i => i.value = '')
        }
      } catch({ response: { data: { error } = {} } = {} }) {
        this.showPopupMessage(error || 'Something went wrong')
      }
    },

    async adminUpdateRepaymentLink() {
      try {
        const { data } = await this.$http.patch(`/contracts/${this.id}/repayment_links/${this.transactionLinkId}`, {
          _csrf_token: this.csrfToken(),
          ...this.extractTransactionLinkAttributes(`transactionLink${this.transactionLinkId}`),
        })

        if (data.success) {
          this.showPopupMessage('Admin updated repayment link successfuly', true)
          this.updateContractAttributes(data.contract)
        }
      } catch({ response: { data: { error } = {} } = {} }) {
        this.showPopupMessage(error || 'Something went wrong')
      }
    },

    async adminDestroyRepaymentLink() {
      try {
        const { data } = await this.$http.patch(`/contracts/${this.id}/repayment_links/${this.transactionLinkId}/destroy`, {
          _csrf_token: this.csrfToken(),
          ...this.extractTransactionLinkAttributes(`transactionLink${this.transactionLinkId}`),
        })

        if (data.success) {
          this.showPopupMessage('Admin destroyed repayment link successfuly', true)
          this.updateContractAttributes(data.contract)
        }
      } catch({ response: { data: { error } = {} } = {} }) {
        this.showPopupMessage(error || 'Something went wrong')
      }
    },

    async startTransactionsUpdater(fetcher) {
      if (this.transactionsUpdaterStarted) return;

      this.transactionsUpdaterStarted = true;
      await fetcher();

      if (!this.escrowHasEnoughConfirmations) {
        const timer = () => {
          this.transactionsUpdaterTimeLeft -= 1;

          if (this.transactionsUpdaterTimeLeft <= 0) {
            this.transactionsUpdaterStarted = false;
            this.startTransactionsUpdater(fetcher);
          } else {
            window.setTimeout(timer, 1000)
          }
        };

        this.transactionsUpdaterTimeLeft = 30; // seconds
        window.setTimeout(timer, 1000);
      } else {
        this.transactionsUpdaterStarted = false;
      }
    },

    async startDispute() {
      const response = await this.$http.post(`/contracts/${this.id}/start_dispute`, {
        _csrf_token: this.csrfToken(),
      });
    },

    async voteNegative() {
      const response = await this.$http.post(`/users/${this.counterpartyLogin}/vote_negative`, {
        _csrf_token: this.csrfToken(),
      });
      if (response["status"] === 200) this.voteRequired = false;
    },

    async votePositive() {
      const response = await this.$http.post(`/users/${this.counterpartyLogin}/vote_positive`, {
        _csrf_token: this.csrfToken(),
      });
      if (response["status"] === 200) this.voteRequired = false;
    },

    confirmPaymentPaidRequest() {
      this.showOtpConfirmationModal('confirm_payment_paid');
      return;
    },

    confirmRepaymentPaidRequest() {
      this.showOtpConfirmationModal('confirm_repayment_paid');
      return;
    },

    csrfToken() {
      return document.querySelector(('input[name=_csrf_token]')).getAttribute('value');
    },

    hideAcceptContractWindow() {
      this.acceptContractWindowVisible = false;
    },

    hideOtpConfirmationWindow({ success, action }) {
      if (success) {
        switch(action) {
          case 'admin_confirm_refund':
            this.confirmRefundByAdmin();
            break;
          case 'admin_confirm_release':
            this.confirmReleaseByAdmin();
            break;
          case 'confirm_cancel':
            this.cancelContract();
            this.cancelContractQuestionnarie = true
            break;
          case 'confirm_forced_liquidation':
            this.forceContractLiquidation();
            break;
          case 'confirm_payment_password':
            this.showPaymentPasswordConfirmationModal();
            break;
          case 'confirm_payment_paid':
            this.showPaymentConfirmationWindow();
            break;
          case 'confirm_repayment_paid':
            this.confirmRepayment();
            break;
          case 'confirm_refund':
            this.showRefundWindow();
            break;
          case 'confirm_release':
            this.showReleaseWindow();
            break;
          case 'borrower_update_refund_address':
            this.showUpdateRefundAddressWindow();
            break;
          case 'lender_update_repayment_address':
            this.showUpdateRepaymentAddressWindow();
            break;
          case 'lender_update_bitcoin_release_address':
            this.showUpdateReleaseAddressWindow();
            break;
          case 'admin_create_payment_link':
            this.adminCreatePaymentLink()
            break
          case 'admin_update_payment_link':
            this.adminUpdatePaymentLink()
            break
          case 'admin_destroy_payment_link':
            this.adminDestroyPaymentLink()
            break
          case 'admin_create_repayment_link':
            this.adminCreateRepaymentLink()
            break
          case 'admin_update_repayment_link':
            this.adminUpdateRepaymentLink()
            break
          case 'admin_destroy_repayment_link':
            this.adminDestroyRepaymentLink()
            break
          default:
            break;
        }
      }

      this.otpConfirmationCancelContractWindowVisible = false;
      this.otpConfirmationWindowVisible = false;
    },

    hidePaymentConfirmationWindow({ success, contract }) {
      if (success) {
        this.updateAjaxContractAttributes(contract);
      }

      this.paymentConfirmationWindowVisible = false;
    },

    async hidePaymentPasswordConfirmationModal({ validated = false, escrowValid = false }) {
      if (validated) {
        const { data } = await this.confirmEscrow(escrowValid);
        if (!data.success) this.showPopupMessage(data.error);
      }

      this.paymentPasswordConfirmationModalVisible = false;
    },

    hidePaymentPasswordModal({ success, encryptedSeed, clientXpub, decryptedSeed }) {
      if (success) {
        this.encryptedSeed = encryptedSeed;
        this.clientXpub = clientXpub;
        this.decryptedSeed = decryptedSeed;
      }

      this.paymentPasswordModalVisible = false;
    },

    hidePaymentTransactionLinkWindow({ success, contract }) {
      if (success) {
        this.updateAjaxContractAttributes(contract);
      }

      this.paymentTransactionLinkWindowVisible = false;
    },

    hidePopupMessage(id) {
      this.popupMessageSuccess = false
      this.popupMessageText = null;
      this.popupMessageVisible = false;
    },

    hideRefundWindow({ success, contract }) {
      if (success) {
        this.updateAjaxContractAttributes(contract);
      }

      this.refundWindowVisible = false;
    },

    hideReleaseWindow({ success , contract }) {
      if (success) {
        this.updateAjaxContractAttributes(contract);
      }

      this.releaseWindowVisible = false;
    },

    hideRepaymentTransactionLinkWindow({ success, contract }) {
      if (success) {
        this.updateAjaxContractAttributes(contract);
      }

      this.repaymentTransactionLinkWindowVisible = false;
    },

    hideTransactionsList() {
      this.transactionsListVisible = false;
    },

    hideRefundTransactionsList() {
      this.refundTransactionsListVisible = false;
    },

    hideReleaseOutputsList() {
      this.releaseOutputsListVisible = false;
    },

    hideUpdateRepaymentAddressWindow({ success, contract }) {
      if (success) {
        this.updateAjaxContractAttributes(contract);
      }

      this.updateRepaymentAddressWindowVisible = false;
    },

    hideUpdateRefundAddressWindow({ success, contract }) {
      if (success) {
        this.updateAjaxContractAttributes(contract);
      }

      this.updateRefundAddressWindowVisible = false;
    },

    hideDownloadBackupModal() {
      this.downloadBackupModalVisible = false;
    },

    hideUpdateReleaseAddressWindow({ success, contract }) {
      if (success) {
        this.updateAjaxContractAttributes(contract);
      }

      this.updateReleaseAddressWindowVisible = false;
    },

    showAcceptContractWindow() {
      this.acceptContractWindowVisible = true
    },

    showOtpConfirmationModal(action) {
      this.otpConfirmationWindowVisible = true;
      this.action = action;
    },

    showPaymentConfirmationWindow() {
      this.paymentConfirmationWindowVisible = true;
    },

    showPaymentPasswordConfirmationModal() {
      this.paymentPasswordConfirmationModalVisible = true;
    },

    showDownloadBackupModal() {
      this.downloadBackupModalVisible = true;
    },

    showPaymentPasswordConfirmationModalRequest() {
      this.showOtpConfirmationModal('confirm_payment_password');
      return;
    },

    showPaymentPasswordModal() {
      this.paymentPasswordModalVisible = true;
    },

    showPaymentTransactionLinkWindow() {
      this.paymentTransactionLinkWindowVisible = true;
    },

    showPopupMessage(message, success) {
      this.popupMessageSuccess = !!success
      this.popupMessageText = message;
      this.popupMessageVisible = true;
    },

    showRefundTransactionsList() {
      this.refundTransactionsListVisible = true
    },

    showRefundWindow() {
      this.refundWindowVisible = true;
    },

    showRefundWindowRequest() {
      this.showOtpConfirmationModal('confirm_refund');
      return;
    },

    showReleaseOutputsList() {
      this.releaseOutputsListVisible = true
    },

    showReleaseWindow() {
      this.releaseWindowVisible = true;
    },

    showReleaseWindowRequest() {
      this.showOtpConfirmationModal('confirm_release');
      return;
    },

    showRepaymentTransactionLinkWindow() {
      this.repaymentTransactionLinkWindowVisible = true;
    },

    showTransactionsList() {
      this.transactionsListVisible = true
    },

    otpConfirmRepaymentAddressUpdate() {
      this.showOtpConfirmationModal('lender_update_repayment_address');
      return;
    },

    showUpdateRepaymentAddressWindow() {
      this.updateRepaymentAddressWindowVisible = true;
    },

    otpConfirmUpdateRefundAddressUpdate() {
      this.showOtpConfirmationModal('borrower_update_refund_address');
      return;
    },

    showUpdateRefundAddressWindow() {
      this.updateRefundAddressWindowVisible = true;
    },

    otpConfirmReleaseAddressUpdate() {
      this.showOtpConfirmationModal('lender_update_bitcoin_release_address');
      return;
    },

    showUpdateReleaseAddressWindow() {
      this.updateReleaseAddressWindowVisible = true;
    },

    stateIn(states) {
      if (typeof states === "string") states = states.split(",");
      return states.includes(this.state);
    },

    backupCanBeDownloaded() {
      return !!(this.encryptedSeed && this.escrowAddress && this.multisigIndex && this.escrowRedeemScript);
    },

    updateAjaxContractAttributes(attributes) {
      this.updateContractAttributes(attributes);

      const camelized = camelizeKeys(attributes);
      ajaxAttributes.forEach(attr => this[attr] = camelized[attr]);
    },

    updateContractAttributes(attributes) {
      const camelized = camelizeKeys(attributes);

      contractAttributes.forEach(attr => this[attr] = camelized[attr]);

      decimalContractAttributes.forEach(attr => {
        this[attr] = camelized[attr] == null ? null : new Big(camelized[attr]);
      });

      dateContractAttributes.forEach(attr => {
        this[attr] = camelized[attr] == null ? null : new Date(camelized[attr]);
      });

      if (camelized.transactions != null) {
        this.updateTransactions(camelized.transactions);
      }

      if (camelized.releaseTransactions != null) {
        this.updateReleaseTransactions(camelized.releaseTransactions);
      }

      if (camelized.chatMessages != null) {
        this.updateChatMessages(camelized.chatMessages);
      }
    },

    updateChatMessages(chatMessages) {
      this.chatHistory = chatMessages.map(msg => ({
        body:        msg.chatMessage.body,
        authorLogin: msg.chatMessage.authorLogin,
        createdAt:   msg.chatMessage.createdAt,
      }));
    },

    updateReleaseTransactions(transactions) {
      this.releaseTransactions = transactions.map(tx => ({
        amount:          new Big(tx.releaseTransaction.amount),
        broadcasted:     tx.releaseTransaction.broadcasted,
        rawTx:           tx.releaseTransaction.rawTx,
        outputs:         tx.releaseTransaction.outputs,
        destination:     tx.releaseTransaction.destination,
        transactionFee: new Big(tx.releaseTransaction.transactionFee),
        txid:            tx.releaseTransaction.txid,
      }));
    },

    updateTransactions(transactions) {
      this.transactions = transactions.map(tx => ({
        address:       tx.transaction.address,
        amount:        new Big(tx.transaction.amount),
        confirmations: tx.transaction.confirmations,
        txid:          tx.transaction.txid,
      }));
    },
  },

  watch: {
    state(newState, _oldState) {
      callback = contractStateCallbacks[newState];
      if (callback != null) callback.call(this);
    },
  },
});
